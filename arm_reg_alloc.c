/*
 * Copyright (c) 2017 Mark Ryan
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <limits.h>
#include <stdlib.h>
#include <string.h>

#include "arm_fpa_dist.h"
#include "arm_int_dist.h"
#include "arm_reg_alloc.h"

/*
 * This needs some explanation as I keep forgetting how it works.
 *
 * The code generator spits out one section of ARM code for each
 * function and procedure including the main procedure.  This code
 * references registers.  Some of these registers, notably R13, are
 * fixed at code generation time.  The majority are not however.
 * Unfixed registers are described as floating.  There's an inftinite
 * number of floating registers but a fixed number of ARM registers.
 * The register allocator's job is to replace each floating register
 * with a fixed register and ensure each fixed register contains the
 * correct value when it is used as a source operand.
 *
 * The register allocator places two restrictions on the code
 * generator.
 *
 * 1. It assumes that no instruction uses the same floating point
 *    register for a source and a destination.  The IR generated by
 *    the parser should never do this.
 * 2. The intersection between the set of fixed registers and
 *    floating registers must be NULL.  That is the code generator
 *    is not allowed to use both 0 as a fixed and floating register.
 *    The first 4 registers of a register class are used to pass
 *    parameters to functions and these registers are fixed at
 *    code generation time.  The code generator cannot then use
 *    registers 0 to 3 as floating registers.
 *
 * The register allocator is called once per section.  It iterates
 * through each instruction replacing floating source and destination
 * registers with fixed registers.  For each source register, we call
 * prv_ensure.  For floating registers, prv_ensure, checks to see if
 * the floating register has already been assigned a fixed register.
 * If it has we just need to update the operand to refer to the fixed
 * register.  If it hasn't we need to allocate a new fixed register to
 * represent that floating register for the time being.  We know that
 * the floating register must have already been allocated earlier in
 * the function, otherwise it could not be used as an operand.  The
 * fact that it is not currently associated with a fixed register means
 * that it must have been spilled to the stack, by an allocation for
 * another register.  We now need to find a new fixed register for the
 * virtual register and load the spilled value into this register.  The
 * same process must be followed when ensuring fixed registers.  We need
 * to check if that register is mapped and if it isn't we need to spill
 * its current contents and load its own value from the stack.
 *
 * Allocation is done via prv_allocate.  Allocation for fixed registers
 * is simple.  We just need to spill the current value assigned to the
 * register and it's ours.  Allocating a floating register is more
 * complex.  We need to first check to see whether any physical registers
 * are available or not.  If one is available we assign it to our floating
 * register and our job is done.  If none are available we need to select
 * one of the already allocated physical registers, spill its current
 * contents and claim it.
 *
 * When we are processing the destination registers of an instruction
 * we only need to call prv_allocate and not prv_ensure.  The reason is
 * that we're replacing the value in the virtual register and so it will
 * no longer be used.  We don't need to load its spilled value from the stack,
 * as there not needed and they shouldn't be there anyway.
 *
 * How do we know which is the best physical register to spill when all
 * physical registers are claimed and we need to allocate a new floating
 * register?  This, unfortunately, is the tricky piece and is intractable
 * in the general case.  This register allocator uses a simple heuristic.
 * Each time the allocator processes an instruction it computes a value
 * called a distance for each physical register used by the instruction.  The
 * distance is an absolute offset from the start of the section and it
 * indicates when the register is next used as a source operand.  If the
 * register is never read from again, its distance is set to -1.  The
 * next array of each register class stores the distances.  So when we need
 * to find a physical register for a floating register and all the physical
 * registers are already taken, we look through the next array of the
 * appropriate register class and choose the register that has the largest
 * distance, i.e., the one t furthest away from the current instruction.
 * We also use the distance calculation to determine when registers are no
 * longer needed.  After a physical register has been used by an instruction
 * it can be returned to the pool of free physical registers if its distance
 * is -1.  We do this for both source and destination registers although
 * strictly speaking the code generator shouldn't be assigned values to
 * registers that are not then used ( although currently it does ).
 *
 * There's one subtelty here and that's one instruction, SWI, implicitly uses
 * registers.  When the code generator generates a specific SWI instruction
 * it needs to note which registers will be used by the instruction.  This
 * information is discarded by the encoder.
 *
 * Finally, the register allocator plays an important part in parameter passing.
 * If a function has more than four parameters of a given type, the 5th and
 * subsequent parameters of that type cannot be passed by register.  Instead
 * they are passed on the stack.   When the callee needs those parameters it
 * needs to load them from the stack into a register, much the same way as the
 * register allocator loads a spilled value from the stack into a register when
 * needed.  It is for this reason parameter passing is implemented with help
 * from the register allocator.  We simply push the 5th and subsequent
 * parameters on the stack before calling the function and then prime the
 * register allocators spill_stack with offsets to the values before we invoke
 * it.  It will then happily pop those values off the stack for us when they are
 * needed.
 */

/* clang-format off */
typedef void (*subtilis_arm_reg_spill_imm_t)(subtilis_arm_section_t *s,
					     subtilis_arm_op_t *current,
					     subtilis_arm_instr_type_t itype,
					     subtilis_arm_ccode_type_t ccode,
					     subtilis_arm_reg_t dest,
					     subtilis_arm_reg_t base,
					     subtilis_arm_reg_t spill_reg,
					     int32_t offset,
					     subtilis_error_t *err);
typedef void (*subtilis_arm_reg_stran_imm_t)(subtilis_arm_section_t *s,
					     subtilis_arm_op_t *current,
					     subtilis_arm_instr_type_t itype,
					     subtilis_arm_ccode_type_t ccode,
					     subtilis_arm_reg_t dest,
					     subtilis_arm_reg_t base,
					     int32_t offset,
					     subtilis_error_t *err);

/* clang-format on */

typedef bool (*subtilis_arm_reg_is_fixed_t)(subtilis_arm_reg_t reg);

struct subtilis_arm_reg_class_t_ {
	size_t max_regs;
	size_t *phys_to_virt;
	int *next;
	size_t vr_reg_count;
	int32_t *spilt_regs;
	size_t *spill_stack;
	size_t spill_top;
	size_t spill_max;
	size_t reg_size;
	int32_t max_offset;
	subtilis_arm_reg_spill_imm_t spill_imm;
	subtilis_arm_reg_stran_imm_t stran_imm;
	subtilis_arm_instr_type_t store_type;
	subtilis_arm_instr_type_t load_type;
	subtilis_arm_reg_is_fixed_t is_fixed;
};

typedef struct subtilis_arm_reg_class_t_ subtilis_arm_reg_class_t;

struct subtilis_arm_reg_ud_t_ {
	subtilis_arm_reg_class_t *int_regs;
	subtilis_arm_reg_class_t *fpa_regs;
	subtilis_arm_section_t *arm_s;
	size_t instr_count;
	subtlis_arm_walker_t int_dist_walker;
	subtlis_arm_walker_t fpa_dist_walker;
	subtilis_dist_data_t dist_data;
};

typedef struct subtilis_arm_reg_ud_t_ subtilis_arm_reg_ud_t;

void subtilis_regs_used_virt_init(subtilis_regs_used_virt_t *regs_usedv)
{
	subtilis_bitset_init(&regs_usedv->int_regs);
	subtilis_bitset_init(&regs_usedv->real_regs);
}

void subtilis_regs_used_virt_free(subtilis_regs_used_virt_t *regs_usedv)
{
	subtilis_bitset_free(&regs_usedv->int_regs);
	subtilis_bitset_free(&regs_usedv->real_regs);
}

/* clang-format off */
static subtilis_arm_reg_class_t *prv_new_regs(
	size_t reg_count, size_t max_regs, size_t reg_start, size_t reg_size,
	size_t args, int32_t max_offset, subtilis_arm_reg_spill_imm_t spill_imm,
	subtilis_arm_reg_stran_imm_t stran_imm,
	subtilis_arm_instr_type_t store_type,
	subtilis_arm_instr_type_t load_type,
	subtilis_arm_reg_is_fixed_t is_fixed, subtilis_error_t *err)

/* clang-format on */
{
	size_t i;
	size_t index;
	subtilis_arm_reg_class_t *regs;
	size_t reg_args = 4;

	regs = calloc(sizeof(*regs), 1);
	if (!regs) {
		subtilis_error_set_oom(err);
		goto on_error;
	}

	regs->phys_to_virt = malloc(sizeof(*regs->phys_to_virt) * max_regs);
	if (!regs->phys_to_virt) {
		subtilis_error_set_oom(err);
		goto on_error;
	}

	regs->next = malloc(sizeof(*regs->next) * max_regs);
	if (!regs->next) {
		subtilis_error_set_oom(err);
		goto on_error;
	}

	if (args <= reg_args) {
		reg_args = args;
		regs->spill_top = 0;
	} else {
		regs->spill_top = args - reg_args;
	}

	regs->spilt_regs = malloc(reg_count * sizeof(int32_t));
	if (!regs->spilt_regs) {
		subtilis_error_set_oom(err);
		goto on_error;
	}
	regs->spill_stack = malloc(reg_count * sizeof(size_t));
	if (!regs->spill_stack) {
		subtilis_error_set_oom(err);
		goto on_error;
	}
	regs->max_regs = max_regs;
	regs->spill_max = regs->spill_top;
	regs->reg_size = reg_size;
	regs->spill_imm = spill_imm;
	regs->stran_imm = stran_imm;
	regs->store_type = store_type;
	regs->load_type = load_type;
	regs->max_offset = max_offset;
	regs->is_fixed = is_fixed;

	for (i = 0; i < reg_count; i++) {
		regs->spilt_regs[i] = -1;
		regs->spill_stack[i] = i * reg_size;
	}
	regs->vr_reg_count = reg_count;

	for (i = 0; i < reg_args; i++) {
		regs->next[i] = -1;
		regs->phys_to_virt[i] = i + reg_start;
	}

	for (; i < max_regs; i++) {
		regs->next[i] = -1;
		regs->phys_to_virt[i] = INT_MAX;
	}

	for (i = reg_args; i < args; i++) {
		index = i - reg_args;
		regs->spilt_regs[i + reg_start] = index * reg_size;
	}

	return regs;

on_error:

	free(regs->spilt_regs);
	free(regs->next);
	free(regs->phys_to_virt);
	free(regs);

	return NULL;
}

static void prv_free_regs(subtilis_arm_reg_class_t *regs)
{
	if (regs) {
		free(regs->spill_stack);
		free(regs->spilt_regs);
		free(regs->next);
		free(regs->phys_to_virt);
		free(regs);
	}
}

static void prv_init_arm_reg_ud(subtilis_arm_reg_ud_t *ud,
				subtilis_arm_section_t *arm_s,
				subtilis_error_t *err)
{
	size_t max_int_regs;
	size_t max_real_regs;

	subtilis_arm_section_max_regs(arm_s, &max_int_regs, &max_real_regs);

	ud->int_regs = prv_new_regs(
	    max_int_regs, SUBTILIS_ARM_REG_MAX_INT_REGS,
	    SUBTILIS_ARM_INT_VIRT_REG_START, sizeof(int32_t),
	    arm_s->stype->int_regs, 4095, subtilis_arm_insert_stran_spill_imm,
	    subtilis_arm_insert_stran_imm, SUBTILIS_ARM_INSTR_STR,
	    SUBTILIS_ARM_INSTR_LDR, subtilis_arm_is_fixed, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	ud->fpa_regs = prv_new_regs(
	    max_real_regs, SUBTILIS_ARM_REG_MAX_FPA_REGS,
	    SUBTILIS_ARM_FPA_VIRT_REG_START, sizeof(double),
	    arm_s->stype->fp_regs, 1023, subtilis_fpa_insert_stran_spill_imm,
	    subtilis_fpa_insert_stran_imm, SUBTILIS_FPA_INSTR_STF,
	    SUBTILIS_FPA_INSTR_LDF, subtilis_fpa_is_fixed, err);
	if (err->type != SUBTILIS_ERROR_OK) {
		prv_free_regs(ud->int_regs);
		return;
	}

	ud->instr_count = 0;
	ud->arm_s = arm_s;

	subtilis_init_int_dist_walker(&ud->int_dist_walker, &ud->dist_data);
	subtilis_init_fpa_dist_walker(&ud->fpa_dist_walker, &ud->dist_data);
}

static int prv_calculate_dist(subtilis_arm_reg_ud_t *ud, size_t reg_num,
			      subtilis_arm_op_t *op,
			      subtlis_arm_walker_t *walker)
{
	subtilis_error_t err;

	subtilis_error_init(&err);

	if (op->next == SIZE_MAX)
		return -1;

	op = &ud->arm_s->op_pool->ops[op->next];

	ud->dist_data.reg_num = reg_num;
	ud->dist_data.last_used = ud->instr_count + 1;

	subtilis_arm_walk_from(ud->arm_s, walker, op, &err);
	if (err.type != SUBTILIS_ERROR_OK)
		return ud->dist_data.last_used;
	else
		return -1;
}

static void prv_free_arm_reg_ud(subtilis_arm_reg_ud_t *ud)
{
	if (!ud)
		return;

	prv_free_regs(ud->fpa_regs);
	prv_free_regs(ud->int_regs);
}

static size_t prv_virt_to_phys(subtilis_arm_reg_class_t *regs,
			       subtilis_arm_reg_t *reg)
{
	size_t i;
	size_t retval = INT_MAX;

	for (i = 0; i < regs->max_regs; i++) {
		if (regs->phys_to_virt[i] == *reg)
			return i;
	}

	return retval;
}

static void prv_update_next(subtilis_arm_reg_ud_t *ud, int count)
{
	size_t i;

	for (i = 0; i < ud->int_regs->max_regs; i++)
		if (ud->int_regs->next[i] != -1)
			ud->int_regs->next[i] += count;

	for (i = 0; i < ud->fpa_regs->max_regs; i++)
		if (ud->fpa_regs->next[i] != -1)
			ud->fpa_regs->next[i] += count;
}

static void prv_load_spilled_reg(subtilis_arm_reg_ud_t *ud,
				 subtilis_arm_op_t *current,
				 subtilis_arm_reg_class_t *regs,
				 subtilis_arm_reg_t virt,
				 subtilis_arm_reg_t phys, subtilis_error_t *err)
{
	subtilis_arm_reg_t base;
	int added_instructions;
	subtilis_arm_section_t *arm_s = ud->arm_s;
	int32_t offset = regs->spilt_regs[virt];

	if (offset == INT_MAX) {
		subtilis_error_set_assertion_failed(err);
		return;
	}

	if (regs->spill_top == 0) {
		subtilis_error_set_assertion_failed(err);
		return;
	}

	offset += arm_s->locals;

	base = 11;
	if (offset > regs->max_offset || offset < -regs->max_offset) {
		regs->spill_imm(arm_s, current, regs->load_type,
				SUBTILIS_ARM_CCODE_AL, phys, base, phys, offset,
				err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
		added_instructions = 2;
	} else {
		regs->stran_imm(arm_s, current, regs->load_type,
				SUBTILIS_ARM_CCODE_AL, phys, base, offset, err);
		added_instructions = 2;
	}

	prv_update_next(ud, added_instructions);

	regs->phys_to_virt[phys] = virt;
	regs->spilt_regs[virt] = INT_MAX;
	regs->spill_top--;
	regs->spill_stack[regs->spill_top] = offset;
	regs->next[phys] = -1;
}

static void prv_spill_reg(subtilis_arm_reg_ud_t *ud, subtilis_arm_op_t *current,
			  size_t assigned, subtilis_arm_reg_class_t *int_regs,
			  subtilis_arm_reg_class_t *regs,
			  subtilis_arm_reg_t reg, subtilis_error_t *err)
{
	size_t i;
	subtilis_arm_reg_t spill_reg;
	int32_t offset;
	subtilis_arm_reg_t base;
	int added_instructions;
	subtilis_arm_section_t *arm_s = ud->arm_s;

	if (regs->spill_top == regs->vr_reg_count) {
		subtilis_error_set_assertion_failed(err);
		return;
	}

	offset = (int32_t)regs->spill_stack[regs->spill_top++] + arm_s->locals;
	if (regs->spill_max < regs->spill_top)
		regs->spill_max = regs->spill_top;

	regs->spilt_regs[assigned] = offset;

	base = 11;
	if (offset > regs->max_offset || offset < -regs->max_offset) {
		/*
		 * We need to find an integer register to act as our base
		 * when spilling the contents of reg_num.  So if we're
		 * currently spilling the contents of a floating point
		 * register we still need to use the int_regs structure
		 * to use as our base.
		 */

		added_instructions = 2;
		for (i = 0; i < int_regs->max_regs; i++)
			if ((int_regs->phys_to_virt[i] == INT_MAX) &&
			    (int_regs != regs || i != reg))
				break;

		if (i == int_regs->max_regs) {
			subtilis_arm_insert_push(arm_s, current,
						 SUBTILIS_ARM_CCODE_AL, 0, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
			spill_reg = 0;
			added_instructions++;
		} else {
			spill_reg = i;
		}
		regs->spill_imm(arm_s, current, regs->store_type,
				SUBTILIS_ARM_CCODE_AL, reg, base, spill_reg,
				offset, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;

		if (i == int_regs->max_regs) {
			subtilis_arm_insert_pop(arm_s, current,
						SUBTILIS_ARM_CCODE_AL, 0, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
			added_instructions++;
		}
	} else {
		regs->stran_imm(arm_s, current, regs->store_type,
				SUBTILIS_ARM_CCODE_AL, reg, base, offset, err);
		added_instructions = 1;
	}

	prv_update_next(ud, added_instructions);
}

static void prv_allocate_fixed(subtilis_arm_reg_ud_t *ud,
			       subtilis_arm_op_t *current,
			       subtilis_arm_reg_class_t *int_regs,
			       subtilis_arm_reg_class_t *regs,
			       subtilis_arm_reg_t *reg, subtilis_error_t *err)
{
	size_t assigned;

	assigned = regs->phys_to_virt[*reg];
	if (assigned != INT_MAX) {
		prv_spill_reg(ud, current, assigned, int_regs, regs, *reg, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	}
}

static void prv_allocate_floating(subtilis_arm_reg_ud_t *ud,
				  subtilis_arm_op_t *current,
				  subtilis_arm_reg_class_t *int_regs,
				  subtilis_arm_reg_class_t *regs,
				  subtilis_arm_reg_t *reg,
				  subtilis_error_t *err)
{
	subtilis_arm_reg_t target_reg;
	int i;
	int next = regs->max_regs;
	int max_next = -1;

	/* Virtual register is not already assigned. */

	for (i = regs->max_regs - 1; i >= 0; i--)
		if (regs->phys_to_virt[i] == INT_MAX)
			break;

	if (i >= 0) {
		target_reg = (size_t)i;
	} else {
		/* No free physical regs.  Need to spill. */

		for (i = 0; i < regs->max_regs; i++)
			if (regs->next[i] > max_next) {
				max_next = regs->next[i];
				next = i;
			}
		if (next == regs->max_regs) {
			subtilis_error_set_assertion_failed(err);
			return;
		}
		target_reg = next;
		prv_spill_reg(ud, current, regs->phys_to_virt[next], int_regs,
			      regs, target_reg, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	}

	*reg = target_reg;
}

static void prv_allocate(subtilis_arm_reg_ud_t *ud, subtilis_arm_op_t *current,
			 subtilis_arm_reg_class_t *int_regs,
			 subtilis_arm_reg_class_t *regs,
			 subtilis_arm_reg_t *reg, subtilis_error_t *err)
{
	size_t assigned;
	size_t virt_num = *reg;

	if (regs->is_fixed(*reg)) {
		if (*reg >= regs->max_regs)
			return;
		prv_allocate_fixed(ud, current, int_regs, regs, reg, err);
	} else {
		assigned = prv_virt_to_phys(regs, reg);
		if (assigned != INT_MAX) {
			*reg = assigned;
		} else {
			prv_allocate_floating(ud, current, int_regs, regs, reg,
					      err);
		}
	}

	if (err->type != SUBTILIS_ERROR_OK)
		return;

	regs->phys_to_virt[*reg] = virt_num;
}

/* Returns true if register is of fixed use, e.g., R13. */

static bool prv_ensure(subtilis_arm_reg_ud_t *ud, subtilis_arm_op_t *current,
		       subtilis_arm_reg_class_t *int_regs,
		       subtilis_arm_reg_class_t *regs, subtilis_arm_reg_t *reg,
		       subtilis_error_t *err)
{
	size_t assigned;
	subtilis_arm_reg_t target_reg;

	if (regs->is_fixed(*reg)) {
		/*
		 * Register has fixed use and is unavailable to user's code
		 * Physical register has already been allocated, e.g., r12, r13
		 */
		if (*reg >= regs->max_regs)
			return true;

		assigned = regs->phys_to_virt[*reg];
		if (assigned != *reg) {
			prv_allocate_fixed(ud, current, int_regs, regs, reg,
					   err);
			if (err->type != SUBTILIS_ERROR_OK)
				return false;
			prv_load_spilled_reg(ud, current, regs, *reg, *reg,
					     err);
			if (err->type != SUBTILIS_ERROR_OK)
				return false;
		}
	} else {
		assigned = prv_virt_to_phys(regs, reg);
		if (assigned != INT_MAX) {
			*reg = assigned;
		} else {
			target_reg = *reg;
			prv_allocate_floating(ud, current, int_regs, regs,
					      &target_reg, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return false;
			prv_load_spilled_reg(ud, current, regs, *reg,
					     target_reg, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return false;
			*reg = target_reg;
		}
	}

	return false;
}

static void prv_alloc_label(void *user_data, subtilis_arm_op_t *op,
			    size_t label, subtilis_error_t *err)
{
	subtilis_arm_reg_ud_t *ud = user_data;

	ud->instr_count++;
}

static subtilis_arm_reg_t *prv_ensure_op2_reg(subtilis_arm_reg_ud_t *ud,
					      subtilis_arm_op_t *op,
					      int *dist_op2,
					      subtilis_arm_reg_t *reg,
					      subtilis_error_t *err)
{
	size_t vreg_op2;
	bool fixed_reg;

	vreg_op2 = *reg;
	fixed_reg = prv_ensure(ud, op, ud->int_regs, ud->int_regs, reg, err);
	if (fixed_reg || (err->type != SUBTILIS_ERROR_OK))
		return NULL;

	*dist_op2 = prv_calculate_dist(ud, vreg_op2, op, &ud->int_dist_walker);
	if (*dist_op2 == -1)
		ud->int_regs->phys_to_virt[*reg] = INT_MAX;

	return reg;
}

static subtilis_arm_reg_t *prv_ensure_op2(subtilis_arm_reg_ud_t *ud,
					  subtilis_arm_op_t *op,
					  subtilis_arm_op2_t *op2,
					  int *dist_op2, subtilis_error_t *err)
{
	if (op2->type == SUBTILIS_ARM_OP2_I32)
		return NULL;

	if (op2->type == SUBTILIS_ARM_OP2_REG)
		return prv_ensure_op2_reg(ud, op, dist_op2, &op2->op.reg, err);
	else if (op2->type == SUBTILIS_ARM_OP2_SHIFTED)
		return prv_ensure_op2_reg(ud, op, dist_op2, &op2->op.shift.reg,
					  err);

	return NULL;
}

static subtilis_arm_reg_t *prv_ensure_op2_shift_reg(subtilis_arm_reg_ud_t *ud,
						    subtilis_arm_op_t *op,
						    subtilis_arm_op2_t *op2,
						    int *dist_op2,
						    subtilis_error_t *err)
{
	if ((op2->type != SUBTILIS_ARM_OP2_SHIFTED) || !op2->op.shift.shift_reg)
		return NULL;

	return prv_ensure_op2_reg(ud, op, dist_op2, &op2->op.shift.shift.reg,
				  err);
}

static void prv_allocate_dest(subtilis_arm_reg_ud_t *ud, subtilis_arm_op_t *op,
			      subtilis_arm_reg_t *dest, subtilis_error_t *err)
{
	int dist_dest;
	size_t vreg_dest = *dest;

	if ((ud->int_regs->is_fixed(vreg_dest)) &&
	    (vreg_dest >= SUBTILIS_ARM_REG_MAX_INT_REGS))
		return;

	prv_allocate(ud, op, ud->int_regs, ud->int_regs, dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;
	dist_dest = prv_calculate_dist(ud, vreg_dest, op, &ud->int_dist_walker);
	if (dist_dest == -1)
		ud->int_regs->phys_to_virt[*dest] = INT_MAX;
	ud->int_regs->next[*dest] = dist_dest;
}

static void prv_allocate_fpa_dest(subtilis_arm_reg_ud_t *ud,
				  subtilis_arm_op_t *op,
				  subtilis_arm_reg_t *dest,
				  subtilis_error_t *err)
{
	int dist_dest;
	size_t vreg_dest = *dest;

	prv_allocate(ud, op, ud->int_regs, ud->fpa_regs, dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	dist_dest = prv_calculate_dist(ud, vreg_dest, op, &ud->fpa_dist_walker);
	if (dist_dest == -1)
		ud->fpa_regs->phys_to_virt[*dest] = INT_MAX;
	ud->fpa_regs->next[*dest] = dist_dest;
}

static void prv_alloc_load_spilled(subtilis_arm_reg_ud_t *ud,
				   subtilis_arm_op_t *op,
				   subtilis_arm_data_instr_t *instr,
				   subtilis_error_t *err)
{
	prv_allocate_dest(ud, op, &instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	prv_load_spilled_reg(ud, op, ud->int_regs, instr->op2.op.reg,
			     instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;
	instr->op2.op.reg = instr->dest;
	instr->ccode = SUBTILIS_ARM_CCODE_NV;

	ud->instr_count++;
}

static void prv_alloc_fpa_load_spilled(subtilis_arm_reg_ud_t *ud,
				       subtilis_arm_op_t *op,
				       subtilis_fpa_data_instr_t *instr,
				       subtilis_error_t *err)
{
	prv_allocate_fpa_dest(ud, op, &instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	prv_load_spilled_reg(ud, op, ud->fpa_regs, instr->op2.reg, instr->dest,
			     err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;
	instr->op2.reg = instr->dest;
	instr->ccode = SUBTILIS_ARM_CCODE_NV;

	ud->instr_count++;
}

static void prv_alloc_mov_instr(void *user_data, subtilis_arm_op_t *op,
				subtilis_arm_instr_type_t type,
				subtilis_arm_data_instr_t *instr,
				subtilis_error_t *err)
{
	int dist_op2;
	int dist_op2_shift;
	subtilis_arm_reg_t *reg;
	subtilis_arm_reg_t *shift_reg;
	size_t assigned;
	subtilis_arm_reg_ud_t *ud = user_data;

	if ((type == SUBTILIS_ARM_INSTR_MOV) &&
	    (instr->op2.type == SUBTILIS_ARM_OP2_REG) &&
	    ((!subtilis_arm_is_fixed(instr->op2.op.reg)) ||
	     (instr->op2.op.reg < SUBTILIS_ARM_REG_MAX_INT_REGS))) {
		assigned = prv_virt_to_phys(ud->int_regs, &instr->op2.op.reg);
		if (assigned == INT_MAX) {
			prv_alloc_load_spilled(ud, op, instr, err);
			return;
		}
	}

	reg = prv_ensure_op2(ud, op, &instr->op2, &dist_op2, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	shift_reg =
	    prv_ensure_op2_shift_reg(ud, op, &instr->op2, &dist_op2_shift, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	prv_allocate_dest(ud, op, &instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	/* Need to check for useless moves */

	if (reg && !shift_reg && ((type != SUBTILIS_ARM_INSTR_MOV) ||
				  (instr->dest != instr->op2.op.reg)))
		ud->int_regs->next[*reg] = dist_op2;

	if (shift_reg)
		ud->int_regs->next[*shift_reg] = dist_op2_shift;

	ud->instr_count++;
}

static void prv_alloc_data_instr(void *user_data, subtilis_arm_op_t *op,
				 subtilis_arm_instr_type_t type,
				 subtilis_arm_data_instr_t *instr,
				 subtilis_error_t *err)
{
	int dist_op1;
	int dist_op2;
	int dist_op2_shift;
	size_t vreg_op1;
	bool fixed_reg_op1;
	subtilis_arm_reg_ud_t *ud = user_data;
	subtilis_arm_reg_t *reg = NULL;
	subtilis_arm_reg_t *shift_reg = NULL;

	vreg_op1 = instr->op1;
	fixed_reg_op1 =
	    prv_ensure(ud, op, ud->int_regs, ud->int_regs, &instr->op1, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	reg = prv_ensure_op2(ud, op, &instr->op2, &dist_op2, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	shift_reg =
	    prv_ensure_op2_shift_reg(ud, op, &instr->op2, &dist_op2_shift, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	if (!fixed_reg_op1) {
		dist_op1 =
		    prv_calculate_dist(ud, vreg_op1, op, &ud->int_dist_walker);
		if (dist_op1 == -1)
			ud->int_regs->phys_to_virt[instr->op1] = INT_MAX;
	}

	prv_allocate_dest(ud, op, &instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	if (!fixed_reg_op1)
		ud->int_regs->next[instr->op1] = dist_op1;
	if (reg)
		ud->int_regs->next[*reg] = dist_op2;
	if (shift_reg)
		ud->int_regs->next[*shift_reg] = dist_op2_shift;

	ud->instr_count++;
}

static void prv_alloc_mul_instr(void *user_data, subtilis_arm_op_t *op,
				subtilis_arm_instr_type_t type,
				subtilis_arm_mul_instr_t *instr,
				subtilis_error_t *err)
{
	int dist_rm;
	int dist_rs;
	size_t vreg_rm;
	bool fixed_reg_rm;
	size_t vreg_rs;
	bool fixed_reg_rs;
	subtilis_arm_reg_ud_t *ud = user_data;

	vreg_rm = instr->rm;
	fixed_reg_rm =
	    prv_ensure(ud, op, ud->int_regs, ud->int_regs, &instr->rm, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	vreg_rs = instr->rs;
	fixed_reg_rs =
	    prv_ensure(ud, op, ud->int_regs, ud->int_regs, &instr->rs, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	if (!fixed_reg_rm) {
		dist_rm =
		    prv_calculate_dist(ud, vreg_rm, op, &ud->int_dist_walker);
		if (dist_rm == -1)
			ud->int_regs->phys_to_virt[instr->rm] = INT_MAX;
	}

	if (!fixed_reg_rs) {
		dist_rs =
		    prv_calculate_dist(ud, vreg_rs, op, &ud->int_dist_walker);
		if (dist_rs == -1)
			ud->int_regs->phys_to_virt[instr->rs] = INT_MAX;
	}

	prv_allocate_dest(ud, op, &instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	if (!fixed_reg_rm)
		ud->int_regs->next[instr->rm] = dist_rm;
	if (!fixed_reg_rs)
		ud->int_regs->next[instr->rs] = dist_rs;

	ud->instr_count++;
}

static void prv_alloc_stran_instr(void *user_data, subtilis_arm_op_t *op,
				  subtilis_arm_instr_type_t type,
				  subtilis_arm_stran_instr_t *instr,
				  subtilis_error_t *err)
{
	int dist_dest;
	int dist_base;
	int dist_op2;
	size_t vreg_dest;
	size_t vreg_base;
	bool fixed_reg_dest;
	bool fixed_reg_base;
	subtilis_arm_reg_t *reg = NULL;
	subtilis_arm_reg_ud_t *ud = user_data;

	if (type == SUBTILIS_ARM_INSTR_STR) {
		vreg_dest = instr->dest;
		fixed_reg_dest = prv_ensure(ud, op, ud->int_regs, ud->int_regs,
					    &instr->dest, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	}

	vreg_base = instr->base;
	fixed_reg_base =
	    prv_ensure(ud, op, ud->int_regs, ud->int_regs, &instr->base, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	reg = prv_ensure_op2(ud, op, &instr->offset, &dist_op2, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	if (!fixed_reg_base) {
		dist_base =
		    prv_calculate_dist(ud, vreg_base, op, &ud->int_dist_walker);
		if (dist_base == -1)
			ud->int_regs->phys_to_virt[instr->base] = INT_MAX;
	}

	if (type == SUBTILIS_ARM_INSTR_STR) {
		if (!fixed_reg_dest) {
			dist_dest = prv_calculate_dist(ud, vreg_dest, op,
						       &ud->int_dist_walker);
			if (dist_dest == -1)
				ud->int_regs->phys_to_virt[instr->dest] =
				    INT_MAX;
			ud->int_regs->next[instr->dest] = dist_dest;
		}
	} else {
		prv_allocate_dest(ud, op, &instr->dest, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	}

	if (!fixed_reg_base)
		ud->int_regs->next[instr->base] = dist_base;
	if (reg)
		ud->int_regs->next[*reg] = dist_op2;

	ud->instr_count++;
}

static void prv_alloc_mtran_instr(void *user_data, subtilis_arm_op_t *op,
				  subtilis_arm_instr_type_t type,
				  subtilis_arm_mtran_instr_t *instr,
				  subtilis_error_t *err)
{
	subtilis_arm_reg_ud_t *ud = user_data;

	/*
	 * TODO: Again mtran is not currently been used as a general
	 * instruction.  We're just inserting it into the code after
	 * register allocation has happened to implement a stack.
	 */

	ud->instr_count++;
}

static void prv_alloc_br_instr(void *user_data, subtilis_arm_op_t *op,
			       subtilis_arm_instr_type_t type,
			       subtilis_arm_br_instr_t *instr,
			       subtilis_error_t *err)
{
	subtilis_arm_reg_ud_t *ud = user_data;

	ud->instr_count++;
}

static void prv_alloc_swi_instr(void *user_data, subtilis_arm_op_t *op,
				subtilis_arm_instr_type_t type,
				subtilis_arm_swi_instr_t *instr,
				subtilis_error_t *err)
{
	size_t i;
	subtilis_arm_reg_t reg;
	subtilis_arm_reg_ud_t *ud = user_data;

	/* SWIs can only use the first 10 regs */

	for (i = 0; i < 10; i++) {
		if ((1 << i) & instr->reg_mask) {
			reg = i;
			prv_allocate_dest(ud, op, &reg, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
		}
	}

	ud->instr_count++;
}

static void prv_alloc_ldrc_instr(void *user_data, subtilis_arm_op_t *op,
				 subtilis_arm_instr_type_t type,
				 subtilis_arm_ldrc_instr_t *instr,
				 subtilis_error_t *err)
{
	subtilis_arm_reg_ud_t *ud = user_data;

	prv_allocate_dest(ud, op, &instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	ud->instr_count++;
}

static void prv_alloc_cmp_instr(void *user_data, subtilis_arm_op_t *op,
				subtilis_arm_instr_type_t type,
				subtilis_arm_data_instr_t *instr,
				subtilis_error_t *err)
{
	int dist_op1;
	int dist_op2;
	int dist_op2_shift;
	size_t vreg_op1;
	bool fixed_reg_op1;
	subtilis_arm_reg_ud_t *ud = user_data;
	subtilis_arm_reg_t *reg = NULL;
	subtilis_arm_reg_t *shift_reg = NULL;

	vreg_op1 = instr->op1;
	fixed_reg_op1 =
	    prv_ensure(ud, op, ud->int_regs, ud->int_regs, &instr->op1, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	reg = prv_ensure_op2(ud, op, &instr->op2, &dist_op2, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	shift_reg =
	    prv_ensure_op2_shift_reg(ud, op, &instr->op2, &dist_op2_shift, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	if (!fixed_reg_op1) {
		dist_op1 =
		    prv_calculate_dist(ud, vreg_op1, op, &ud->int_dist_walker);
		if (dist_op1 == -1)
			ud->int_regs->phys_to_virt[instr->op1] = INT_MAX;

		ud->int_regs->next[instr->op1] = dist_op1;
	}
	if (reg)
		ud->int_regs->next[*reg] = dist_op2;
	if (shift_reg)
		ud->int_regs->next[*shift_reg] = dist_op2_shift;

	ud->instr_count++;
}

static void prv_alloc_fpa_data_dyadic_instr(void *user_data,
					    subtilis_arm_op_t *op,
					    subtilis_arm_instr_type_t type,
					    subtilis_fpa_data_instr_t *instr,
					    subtilis_error_t *err)
{
	int dist_op1;
	int dist_op2;
	size_t vreg_op1;
	size_t vreg_op2;
	subtilis_arm_reg_ud_t *ud = user_data;

	vreg_op1 = instr->op1;
	(void)prv_ensure(ud, op, ud->int_regs, ud->fpa_regs, &instr->op1, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	if (!instr->immediate) {
		vreg_op2 = instr->op2.reg;
		(void)prv_ensure(ud, op, ud->int_regs, ud->fpa_regs,
				 &instr->op2.reg, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
		dist_op2 =
		    prv_calculate_dist(ud, vreg_op2, op, &ud->fpa_dist_walker);
		if (dist_op2 == -1)
			ud->fpa_regs->phys_to_virt[instr->op2.reg] = INT_MAX;
	}

	dist_op1 = prv_calculate_dist(ud, vreg_op1, op, &ud->fpa_dist_walker);
	if (dist_op1 == -1)
		ud->fpa_regs->phys_to_virt[instr->op1] = INT_MAX;

	prv_allocate_fpa_dest(ud, op, &instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	ud->fpa_regs->next[instr->op1] = dist_op1;
	if (!instr->immediate)
		ud->fpa_regs->next[instr->op2.reg] = dist_op2;

	ud->instr_count++;
}

static void prv_alloc_fpa_data_monadic_instr(void *user_data,
					     subtilis_arm_op_t *op,
					     subtilis_arm_instr_type_t type,
					     subtilis_fpa_data_instr_t *instr,
					     subtilis_error_t *err)
{
	int dist_op2;
	size_t vreg_op2;
	size_t assigned;
	subtilis_arm_reg_ud_t *ud = user_data;

	if (!instr->immediate) {
		if (type == SUBTILIS_FPA_INSTR_MVF) {
			assigned =
			    prv_virt_to_phys(ud->fpa_regs, &instr->op2.reg);
			if (assigned == INT_MAX) {
				prv_alloc_fpa_load_spilled(ud, op, instr, err);
				return;
			}
		}

		vreg_op2 = instr->op2.reg;
		(void)prv_ensure(ud, op, ud->int_regs, ud->fpa_regs,
				 &instr->op2.reg, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
		dist_op2 =
		    prv_calculate_dist(ud, vreg_op2, op, &ud->fpa_dist_walker);
		if (dist_op2 == -1)
			ud->fpa_regs->phys_to_virt[instr->op2.reg] = INT_MAX;
	}

	prv_allocate_fpa_dest(ud, op, &instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	/* Need to check for useless moves */

	if (!instr->immediate &&
	    ((type != SUBTILIS_FPA_INSTR_MVF) || instr->op2.reg != instr->dest))
		ud->fpa_regs->next[instr->op2.reg] = dist_op2;

	ud->instr_count++;
}

static void prv_alloc_fpa_stran_instr(void *user_data, subtilis_arm_op_t *op,
				      subtilis_arm_instr_type_t type,
				      subtilis_fpa_stran_instr_t *instr,
				      subtilis_error_t *err)
{
	int dist_dest;
	int dist_base;
	size_t vreg_dest;
	size_t vreg_base;
	bool fixed_reg_base;
	subtilis_arm_reg_ud_t *ud = user_data;

	/*
	 * The function calling code can generate LDFNV and STFNV when
	 * preserving fpa registers.  These instructions should be
	 * ignored for the purposes of register allocation.
	 */

	if (instr->ccode == SUBTILIS_ARM_CCODE_NV) {
		ud->instr_count++;
		return;
	}

	if (type == SUBTILIS_FPA_INSTR_STF) {
		vreg_dest = instr->dest;
		(void)prv_ensure(ud, op, ud->int_regs, ud->fpa_regs,
				 &instr->dest, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	}

	vreg_base = instr->base;
	fixed_reg_base =
	    prv_ensure(ud, op, ud->int_regs, ud->int_regs, &instr->base, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	if (!fixed_reg_base) {
		dist_base =
		    prv_calculate_dist(ud, vreg_base, op, &ud->int_dist_walker);
		if (dist_base == -1)
			ud->int_regs->phys_to_virt[instr->base] = INT_MAX;
	}

	if (type == SUBTILIS_FPA_INSTR_STF) {
		dist_dest =
		    prv_calculate_dist(ud, vreg_dest, op, &ud->fpa_dist_walker);
		if (dist_dest == -1)
			ud->fpa_regs->phys_to_virt[instr->dest] = INT_MAX;
		ud->fpa_regs->next[instr->dest] = dist_dest;
	} else {
		prv_allocate_fpa_dest(ud, op, &instr->dest, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	}

	if (!fixed_reg_base)
		ud->int_regs->next[instr->base] = dist_base;

	ud->instr_count++;
}

static void prv_alloc_fpa_tran_instr(void *user_data, subtilis_arm_op_t *op,
				     subtilis_arm_instr_type_t type,
				     subtilis_fpa_tran_instr_t *instr,
				     subtilis_error_t *err)
{
	size_t vreg_op2;
	int dist_op2;
	subtilis_arm_reg_ud_t *ud = user_data;
	bool fixed_op2 = true;

	if (type != SUBTILIS_FPA_INSTR_FLT) {
		if (!instr->immediate) {
			vreg_op2 = instr->op2.reg;
			prv_ensure(ud, op, ud->int_regs, ud->fpa_regs,
				   &instr->op2.reg, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
			dist_op2 = prv_calculate_dist(ud, vreg_op2, op,
						      &ud->fpa_dist_walker);
			if (dist_op2 == -1)
				ud->fpa_regs->phys_to_virt[instr->op2.reg] =
				    INT_MAX;
		}

		prv_allocate_dest(ud, op, &instr->dest, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	} else {
		if (!instr->immediate) {
			vreg_op2 = instr->op2.reg;
			fixed_op2 =
			    prv_ensure(ud, op, ud->int_regs, ud->int_regs,
				       &instr->op2.reg, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
			dist_op2 = prv_calculate_dist(ud, vreg_op2, op,
						      &ud->int_dist_walker);
			if (dist_op2 == -1)
				ud->int_regs->phys_to_virt[instr->op2.reg] =
				    INT_MAX;
		}

		prv_allocate_fpa_dest(ud, op, &instr->dest, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;

		if (!fixed_op2)
			ud->int_regs->next[instr->op2.reg] = dist_op2;
	}

	ud->instr_count++;
}

static void prv_alloc_fpa_cmp_instr(void *user_data, subtilis_arm_op_t *op,
				    subtilis_arm_instr_type_t type,
				    subtilis_fpa_cmp_instr_t *instr,
				    subtilis_error_t *err)
{
	int dist_dest;
	int dist_op2;
	size_t vreg_dest;
	size_t vreg_op2;
	subtilis_arm_reg_ud_t *ud = user_data;

	vreg_dest = instr->dest;
	(void)prv_ensure(ud, op, ud->int_regs, ud->fpa_regs, &instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	if (!instr->immediate) {
		vreg_op2 = instr->op2.reg;
		(void)prv_ensure(ud, op, ud->int_regs, ud->fpa_regs,
				 &instr->op2.reg, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
		dist_op2 =
		    prv_calculate_dist(ud, vreg_op2, op, &ud->fpa_dist_walker);
		if (dist_op2 == -1)
			ud->fpa_regs->phys_to_virt[instr->op2.reg] = INT_MAX;
		ud->fpa_regs->next[instr->op2.reg] = dist_op2;
	}

	dist_dest = prv_calculate_dist(ud, vreg_dest, op, &ud->fpa_dist_walker);
	if (dist_dest == -1)
		ud->fpa_regs->phys_to_virt[instr->dest] = INT_MAX;
	ud->fpa_regs->next[instr->dest] = dist_dest;

	ud->instr_count++;
}

static void prv_alloc_fpa_ldrc_instr(void *user_data, subtilis_arm_op_t *op,
				     subtilis_arm_instr_type_t type,
				     subtilis_fpa_ldrc_instr_t *instr,
				     subtilis_error_t *err)
{
	subtilis_arm_reg_ud_t *ud = user_data;

	prv_allocate_fpa_dest(ud, op, &instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	ud->instr_count++;
}

size_t subtilis_arm_reg_alloc(subtilis_arm_section_t *arm_s,
			      subtilis_error_t *err)
{
	subtlis_arm_walker_t walker;
	subtilis_arm_reg_ud_t ud;
	size_t retval;

	prv_init_arm_reg_ud(&ud, arm_s, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return 0;

	walker.user_data = &ud;
	walker.label_fn = prv_alloc_label;
	walker.data_fn = prv_alloc_data_instr;
	walker.mul_fn = prv_alloc_mul_instr;
	walker.cmp_fn = prv_alloc_cmp_instr;
	walker.mov_fn = prv_alloc_mov_instr;
	walker.stran_fn = prv_alloc_stran_instr;
	walker.mtran_fn = prv_alloc_mtran_instr;
	walker.br_fn = prv_alloc_br_instr;
	walker.swi_fn = prv_alloc_swi_instr;
	walker.ldrc_fn = prv_alloc_ldrc_instr;
	walker.fpa_data_monadic_fn = prv_alloc_fpa_data_monadic_instr;
	walker.fpa_data_dyadic_fn = prv_alloc_fpa_data_dyadic_instr;
	walker.fpa_stran_fn = prv_alloc_fpa_stran_instr;
	walker.fpa_tran_fn = prv_alloc_fpa_tran_instr;
	walker.fpa_cmp_fn = prv_alloc_fpa_cmp_instr;
	walker.fpa_ldrc_fn = prv_alloc_fpa_ldrc_instr;

	subtilis_arm_walk(arm_s, &walker, err);

	if (err->type != SUBTILIS_ERROR_OK)
		goto cleanup;

	arm_s->reg_counter = 16;

	retval = (ud.int_regs->spill_max * sizeof(int32_t)) +
		 (ud.fpa_regs->spill_max * sizeof(double));

	prv_free_arm_reg_ud(&ud);

	return retval;

cleanup:

	prv_free_arm_reg_ud(&ud);

	return 0;
}

static bool prv_is_reg_used_before(subtilis_arm_reg_ud_t *ud, size_t reg_num,
				   subtlis_arm_walker_t *dist_walker,
				   subtilis_arm_op_t *from,
				   subtilis_arm_op_t *to)
{
	subtilis_error_t err;
	size_t i;

	ud->dist_data.reg_num = reg_num;

	do {
		subtilis_error_init(&err);
		ud->dist_data.last_used = 0;
		subtilis_arm_walk_from_to(ud->arm_s, dist_walker, from, to,
					  &err);
		if (err.type == SUBTILIS_ERROR_OK)
			return false;
		else if (ud->dist_data.last_used == -1)
			return true;

		/*
		 * We arrive here if reg_num is read from but not written to
		 * by one instruction in the region.  We need to keep checking.
		 * from the subsequent instruction.
		 */

		for (i = 0; i < ud->dist_data.last_used + 1; i++) {
			if ((from == to) || (from->next == SIZE_MAX))
				return false;

			from = &ud->arm_s->op_pool->ops[from->next];
		}
	} while (true);

	return false;
}

void subtilis_arm_regs_used_before_from_tov(subtilis_arm_section_t *arm_s,
					    subtilis_arm_op_t *from,
					    subtilis_arm_op_t *op,
					    size_t int_args, size_t real_args,
					    subtilis_regs_used_virt_t *used,
					    subtilis_error_t *err)
{
	size_t i;
	subtilis_arm_reg_ud_t ud;

	prv_init_arm_reg_ud(&ud, arm_s, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	for (i = SUBTILIS_ARM_INT_VIRT_REG_START; i < int_args; i++) {
		if (prv_is_reg_used_before(&ud, i, &ud.int_dist_walker, from,
					   op)) {
			subtilis_bitset_set(&used->int_regs, i, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
		}
	}

	for (i = SUBTILIS_ARM_FPA_VIRT_REG_START; i < real_args; i++) {
		if (prv_is_reg_used_before(&ud, i, &ud.fpa_dist_walker, from,
					   op)) {
			subtilis_bitset_set(&used->real_regs, i, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
		}
	}

	prv_free_arm_reg_ud(&ud);
}

void subtilis_arm_regs_used_before_from_to(subtilis_arm_section_t *arm_s,
					   subtilis_arm_op_t *from,
					   subtilis_arm_op_t *op,
					   size_t int_args, size_t real_args,
					   subtilis_regs_used_t *regs_used,
					   subtilis_error_t *err)
{
	size_t i;
	subtilis_arm_reg_ud_t ud;
	size_t int_reg_list = 0;
	size_t fpa_reg_list = 0;

	prv_init_arm_reg_ud(&ud, arm_s, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	i = int_args;
	if (i > SUBTILIS_ARM_REG_MIN_INT_REGS)
		i = SUBTILIS_ARM_REG_MIN_INT_REGS;
	for (; i <= SUBTILIS_ARM_REG_MAX_INT_REGS; i++) {
		if (prv_is_reg_used_before(&ud, i, &ud.int_dist_walker, from,
					   op))
			int_reg_list |= 1 << i;
	}

	i = real_args;
	if (i > SUBTILIS_ARM_REG_MIN_FPA_REGS)
		i = SUBTILIS_ARM_REG_MIN_FPA_REGS;
	for (; i < SUBTILIS_ARM_REG_MAX_FPA_REGS; i++) {
		if (prv_is_reg_used_before(&ud, i, &ud.fpa_dist_walker, from,
					   op))
			fpa_reg_list |= 1 << i;
	}

	regs_used->int_regs = int_reg_list;
	regs_used->fpa_regs = fpa_reg_list;

	prv_free_arm_reg_ud(&ud);
}

void subtilis_arm_regs_used_before(subtilis_arm_section_t *arm_s,
				   subtilis_arm_op_t *op, size_t int_args,
				   size_t real_args,
				   subtilis_regs_used_t *regs_used,
				   subtilis_error_t *err)
{
	subtilis_arm_op_t *from;

	from = &arm_s->op_pool->ops[arm_s->first_op];
	subtilis_arm_regs_used_before_from_to(arm_s, from, op, int_args,
					      real_args, regs_used, err);
}

static bool prv_is_reg_used_after_to(subtilis_arm_reg_ud_t *ud, size_t reg_num,
				     subtlis_arm_walker_t *dist_walker,
				     subtilis_arm_op_t *from,
				     subtilis_arm_op_t *to)
{
	subtilis_error_t err;

	subtilis_error_init(&err);

	ud->dist_data.reg_num = reg_num;
	ud->dist_data.last_used = ud->instr_count + 1;

	subtilis_arm_walk_from_to(ud->arm_s, dist_walker, from, to, &err);

	/*
	 * Check that reg_num is used and that the  first usage of
	 * reg_num is not a write.
	 */

	return (err.type != SUBTILIS_ERROR_OK) &&
	       (ud->dist_data.last_used != -1);
}

void subtilis_arm_regs_used_afterv(subtilis_arm_section_t *arm_s,
				   subtilis_arm_op_t *from,
				   subtilis_arm_op_t *to, size_t int_args,
				   size_t real_args, size_t count,
				   subtilis_regs_used_virt_t *used,
				   subtilis_error_t *err)
{
	size_t i;
	subtilis_arm_reg_ud_t ud;

	prv_init_arm_reg_ud(&ud, arm_s, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;
	ud.instr_count = count + 1;

	for (i = SUBTILIS_ARM_INT_VIRT_REG_START; i < int_args; i++) {
		if (prv_is_reg_used_after_to(&ud, i, &ud.int_dist_walker, from,
					     to)) {
			subtilis_bitset_set(&used->int_regs, i, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
		}
	}

	for (i = SUBTILIS_ARM_FPA_VIRT_REG_START; i < real_args; i++) {
		if (prv_is_reg_used_after_to(&ud, i, &ud.fpa_dist_walker, from,
					     to)) {
			subtilis_bitset_set(&used->real_regs, i, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
		}
	}

	prv_free_arm_reg_ud(&ud);
}

static bool prv_is_reg_used_after(subtilis_arm_reg_ud_t *ud, size_t reg_num,
				  subtlis_arm_walker_t *dist_walker,
				  subtilis_arm_op_t *from)
{
	subtilis_arm_op_t *to;

	to = &ud->arm_s->op_pool->ops[ud->arm_s->last_op];
	return prv_is_reg_used_after_to(ud, reg_num, dist_walker, from, to);
}

void subtilis_arm_regs_used_after(subtilis_arm_section_t *arm_s,
				  subtilis_arm_op_t *op, size_t int_args,
				  size_t real_args,
				  subtilis_regs_used_t *regs_used,
				  subtilis_error_t *err)
{
	size_t i;
	subtilis_arm_reg_ud_t ud;
	size_t int_reg_list = 0;
	size_t fpa_reg_list = 0;

	prv_init_arm_reg_ud(&ud, arm_s, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	i = int_args;
	if (i > SUBTILIS_ARM_REG_MIN_INT_REGS)
		i = SUBTILIS_ARM_REG_MIN_INT_REGS;
	for (; i <= SUBTILIS_ARM_REG_MAX_INT_REGS; i++) {
		if (prv_is_reg_used_after(&ud, i, &ud.int_dist_walker, op))
			int_reg_list |= 1 << i;
	}

	i = real_args;
	if (i > SUBTILIS_ARM_REG_MIN_FPA_REGS)
		i = SUBTILIS_ARM_REG_MIN_FPA_REGS;
	for (; i < SUBTILIS_ARM_REG_MAX_FPA_REGS; i++) {
		if (prv_is_reg_used_after(&ud, i, &ud.fpa_dist_walker, op))
			fpa_reg_list |= 1 << i;
	}

	regs_used->int_regs = int_reg_list;
	regs_used->fpa_regs = fpa_reg_list;

	prv_free_arm_reg_ud(&ud);
}

void subtilis_arm_save_regs(subtilis_arm_section_t *arm_s,
			    subtilis_error_t *err)
{
	size_t i;
	size_t start;
	size_t end;
	size_t int_regs_used;
	size_t real_regs_used;
	size_t real_regs_saved;
	subtilis_arm_call_site_t *call_site;
	subtilis_regs_used_t regs_used_before;
	subtilis_regs_used_t regs_used_after;
	subtilis_arm_mtran_instr_t *mtran;
	subtilis_arm_op_t *op;
	size_t fpa_reg_count;
	size_t j;

	for (i = 0; i < arm_s->call_site_count; i++) {
		call_site = &arm_s->call_sites[i];
		end = arm_s->op_pool->ops[call_site->stm_site].prev;
		if (end != SIZE_MAX) {
			subtilis_arm_regs_used_before(
			    arm_s, &arm_s->op_pool->ops[end],
			    call_site->int_args, call_site->real_args,
			    &regs_used_before, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
		}

		start = arm_s->op_pool->ops[call_site->ldm_site].next;
		if (start == SIZE_MAX)
			continue;

		subtilis_arm_regs_used_after(arm_s, &arm_s->op_pool->ops[start],
					     call_site->int_args,
					     call_site->real_args,

					     &regs_used_after, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;

		int_regs_used =
		    regs_used_before.int_regs & regs_used_after.int_regs;

		op = &arm_s->op_pool->ops[call_site->stm_site];
		mtran = &op->op.instr.operands.mtran;
		mtran->reg_list |= int_regs_used;
		op = &arm_s->op_pool->ops[call_site->ldm_site];
		mtran = &op->op.instr.operands.mtran;
		mtran->reg_list |= int_regs_used;

		if (call_site->ldf_site == INT_MAX)
			continue;

		real_regs_used =
		    regs_used_before.fpa_regs & regs_used_after.fpa_regs;

		real_regs_saved = arm_s->call_sites[i].real_args;
		if (real_regs_saved > SUBTILIS_ARM_REG_MIN_FPA_REGS)
			real_regs_saved = 2;
		else
			real_regs_saved =
			    SUBTILIS_ARM_REG_MAX_FPA_REGS - real_regs_saved;

		fpa_reg_count = SUBTILIS_ARM_REG_MAX_FPA_REGS - real_regs_saved;
		op = &arm_s->op_pool->ops[call_site->stf_site];

		for (; fpa_reg_count < SUBTILIS_ARM_REG_MAX_FPA_REGS;
		     fpa_reg_count++) {
			if (real_regs_used & (1 << fpa_reg_count)) {
				op->op.instr.operands.fpa_stran.ccode =
				    SUBTILIS_ARM_CCODE_AL;
			}
			op = &arm_s->op_pool->ops[op->next];
		}

		fpa_reg_count = SUBTILIS_ARM_REG_MAX_FPA_REGS - 1;
		op = &arm_s->op_pool->ops[call_site->ldf_site];
		for (j = 0; j < real_regs_saved; j++) {
			if (real_regs_used & (1 << fpa_reg_count))
				op->op.instr.operands.fpa_stran.ccode =
				    SUBTILIS_ARM_CCODE_AL;
			op = &arm_s->op_pool->ops[op->next];
			fpa_reg_count--;
		}
	}
}
